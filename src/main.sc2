sprite Stage {
    costumes {
        "backdrop": "assets/blank.gif",
    }
}

sprite Main {
    costumes {
        "costume": "assets/blank.gif",
    }

    fn when-flag-clicked {
        lex("3⍳ 10_20_30+ #This is a comment")
        parse()
        compute-signatures()
        heap.delete-all()
        ptrs.delete-all()
        sizes.delete-all()
        x(1)
    }

    let tokens = [] as List[String]

    fn lex(_ source-code: String) {
        tokens.delete-all()
        let buffer = ""
        let comment = "false"
        for i length(source-code) {
            if comment == "true" {
                if source-code.letter(i) == "\n" {
                    &comment = "false"
                }
            } else if "0123456789_".contains(source-code.letter(i)) {
                &buffer = buffer.join(source-code.letter(i))
            } else {
                if not(buffer == "") {
                    tokens.push(buffer)
                }
                &buffer = ""
                if not(" \n".contains(source-code.letter(i))) {
                    if source-code.letter(i) == "#" {
                        &comment = "true"
                    } else {
                        tokens.push(source-code.letter(i))
                    }
                }
            }
        }
        if not(buffer == "") {
            tokens.push(buffer)
        }
    }

    let ast-ops = [] as List[String]
    let ast-sizes = [] as List[Num]
    let ast-i = [] as List[Num]
    let ast-o = [] as List[Num]
    let parser-stack = [] as List[Num]

    fn parse {
        ast-ops.delete-all()
        ast-sizes.delete-all()
        parser-stack.delete-all()
        start("(")
        for token length(tokens) {
            let token = tokens.at(token)
            if "(/\\".contains(token) { start(token) }
            else if "{[".contains(token) { start(token) start("(") }
            else if token == ")" { finish() finish-modifier() }
            else if "}]".contains(token) { finish() finish() finish-modifier() }
            else if token == "|" { finish() start("(") }
            else if "+-×↧↥<≤=@▽,⧻⍳⇌⍏⍖·○".contains(token) {
                start(token)
                finish()
                finish-modifier()
            } else {
                start("_")
                let buffer = ""
                for c length(token) {
                    let c = token.letter(c)
                    if c == "_" {
                        if not(buffer == "") {
                            start(buffer)
                            finish()
                            &buffer = ""
                        }
                    } else {
                        &buffer = buffer.join(c)
                    }
                }
                if not(buffer == "") {
                    start(buffer)
                    finish()
                }
                finish()
                finish-modifier()
            }
        }
        finish()
    }

    fn finish-modifier {
        if "/\\".contains(ast-ops.at(last(parser-stack))) {
            finish()
        }
    }

    fn start(_ op: String) {
        ast-ops.push(op)
        ast-sizes.push(0)
        parser-stack.push(length(ast-ops))
    }

    fn finish {
        ast-sizes.replace(index: last(parser-stack), with: length(ast-ops) - last(parser-stack) + 1)
        pop(parser-stack)
    }

    fn compute-signatures {
        ast-i.delete-all()
        ast-o.delete-all()
        for i length(ast-ops) {
            ast-i.push(0)
            ast-o.push(0)
        }
        for node length(ast-ops) {
            let node = length(ast-ops) - node + 1
            let op = op(node)
            if op == "(" {
                let end = node + ast-sizes.at(node)
                let next = node + 1
                let i_ = 0
                let o_ = 0
                until next == end {
                    let i = ast-i.at(next)
                    let o = ast-o.at(next)
                    if o_ < i {
                        &i_ = i_ + i - o_
                        &o_ = o
                    } else {
                        &o_ = o_ + o - i
                    }
                    &next = next + ast-sizes.at(next)
                }
                node.set-signature(i_, o_)
            } else if op == "_" { node.set-signature(0, 1) }
            else if "+-×↧↥<≤=@▽,".contains(op) { node.set-signature(2, 1) }
            else if "/\\".contains(op) {
                if not((ast-i.at(node + 1) == 2).and(ast-o.at(node + 1) == 1)) {
                    die("invalid signature for ".join(op))
                }
                node.set-signature(1, 1)
            } else if "⧻⍳⇌⍏⍖·".contains(op) { node.set-signature(1, 1) }
            else if op == "○" { node.set-signature(1, 0) }
            else if op == "{" {
                let end = node + ast-sizes.at(node)
                let next = node + 1
                let i = 0
                let o = 0
                until next == end {
                    if i < ast-i.at(next) { &i = ast-i.at(next) }
                    &o = o + ast-o.at(next)
                    &next = next + ast-sizes.at(next)
                }
                node.set-signature(i, o)
            } else if op == "[" {
                let end = node + ast-sizes.at(node)
                let next = node + 1
                let i = 0
                let o = 0
                until next == end {
                    &i = i + ast-i.at(next)
                    &o = o + ast-o.at(next)
                    &next = next + ast-sizes.at(next)
                }
                node.set-signature(i, o)
            } else {} # Unknown op
        }
    }

    inline fn set-signature(_ node: Num, _ i: Num, _ o: Num) {
        ast-i.replace(index: node, with: i)
        ast-o.replace(index: node, with: o)
    }

    let heap = [] as List[Num]
    let ptrs = [] as List[Num]
    let sizes = [] as List[Num]

    fn x(_ node: Num) {
        # Memory model: arrays are shared, so don't modify them in place.
        let op = op(node)
        if op == "(" {
            let end = node + ast-sizes.at(node)
            let next = node + 1
            until next == end {
                x(next)
                &next = next + ast-sizes.at(next)
            }
        } else if op == "_" {
            ptrs.push(length(heap) + 1)
            sizes.push(ast-sizes.at(node) - 1)
            for i last(sizes) {
                heap.push(op(node + i).to-num())
            }
        } else if "+-×↧↥<≤=".contains(op) {
            let sa = sizes.bat(1)
            let sb = last(sizes)
            let size = sa
            if (sb == 0).or(sa < sb) { &size = sb }
            for i size {
                let a = ptrs.bat(1).at((i - 1) % sa)
                let b = last(ptrs).at((i - 1) % sb)
                if op == "+" { heap.push(a + b) }
                else if op == "-" { heap.push(a - b) }
                else if op == "×" { heap.push(a * b) }
                else if op == "↧" {
                    if a < b { heap.push(a) }
                    else { heap.push(b) }
                } else if op == "↥" {
                    if a < b { heap.push(b) }
                    else { heap.push(a) }
                } else if op == "<" { # TODO: Add `Bool.to-num` to SC2
                    if a < b { heap.push(1) }
                    else { heap.push(0) }
                } else if op == "≤" {
                    if b < a { heap.push(0) }
                    else { heap.push(1) }
                } else {
                    if a == b { heap.push(1) }
                    else { heap.push(0) }
                }
            }
            pop(ptrs)
            pop(sizes)
            ptrs.replace-last(with: length(heap) - size + 1)
            sizes.replace-last(with: size)
        } else if op == "@" {
            for i last(sizes) {
                heap.push(ptrs.bat(1).at(last(ptrs).at(i - 1)))
            }
            ptrs.replace-last(with: length(heap) - last(sizes) + 1)
            ptrs.belete(index: 1)
            sizes.belete(index: 1)
        } else if op == "▽" {} # TODO
        else if op == "," {
            for i sizes.bat(1) {
                heap.push(ptrs.bat(1).at(i - 1))
            }
            for i last(sizes) {
                heap.push(last(ptrs).at(i - 1))
            }
            sizes.replace-last(with: last(sizes) + sizes.bat(1))
            sizes.belete(index: 1)
            ptrs.replace-last(with: length(heap) - last(sizes) + 1)
            ptrs.belete(index: 1)
        } else if op == "⧻" {
            heap.push(last(sizes))
            ptrs.replace-last(with: length(heap))
            sizes.replace-last(with: 1)
        } else if op == "⍳" {
            if not(last(sizes) == 1) { die("invalid length for ⍳") }
            sizes.replace-last(with: heap.at(last(ptrs)))
            ptrs.replace-last(with: length(heap) + 1)
            for i last(sizes) {
                heap.push(i - 1)
            }
        } else if op == "⇌" {
            let i = last(ptrs) + last(sizes)
            repeat last(sizes) {
                &i = i - 1
                heap.push(heap.at(i))
            }
            ptrs.replace-last(with: length(heap) - last(sizes) + 1)
        } else if op == "⍏" {} # TODO
        else if op == "⍖" {} # TODO
        else if op == "/" {} # TODO
        else if op == "\\" {} # TODO
        else if op == "○" { pop(ptrs) pop(sizes) }
        else if op == "{" {} # TODO
        else if op == "[" {} # TODO
    }

    inline fn op(_ node: Num) -> String {
        ast-ops.at(node)
    }

    fn die(_ message: String) {
        say(message)
        stop-all()
    }

    inline fn bat(_ comptime list: List[Num], _ index: Num) -> Num {
        list.at(length(list) - index)
    }

    inline fn belete(_ comptime list: List[Num], index index: Num) {
        list.delete(index: length(list) - index)
    }

    inline fn at(_ ptr: Num, _ index: Num) -> Num {
        heap.at(ptr + index)
    }
}
