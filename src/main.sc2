sprite Stage {
    costumes {
        "backdrop": "assets/blank.gif",
    }
}

sprite Main {
    costumes {
        "costume": "assets/blank.gif",
    }

    fn when-flag-clicked {
        lex("3⍳ 10_20_30+ #This is a comment")
        parse()
    }

    let tokens = [] as List[String]

    fn lex(_ source-code: String) {
        tokens.delete-all()
        let buffer = ""
        let comment = "false"
        for i length(source-code) {
            if comment == "true" {
                if source-code.letter(i) == "\n" {
                    &comment = "false"
                }
            } else if "0123456789_".contains(source-code.letter(i)) {
                &buffer = buffer.join(source-code.letter(i))
            } else {
                if not(buffer == "") {
                    tokens.push(buffer)
                }
                &buffer = ""
                if not(" \n".contains(source-code.letter(i))) {
                    if source-code.letter(i) == "#" {
                        &comment = "true"
                    } else {
                        tokens.push(source-code.letter(i))
                    }
                }
            }
        }
        if not(buffer == "") {
            tokens.push(buffer)
        }
    }

    let ast-ops = [] as List[String]
    let ast-sizes = [] as List[Num]
    let parser-stack = [] as List[Num]

    fn parse {
        for token length(tokens) {
            let token = tokens.at(token)
            if "(/\\".contains(token) { start(token) }
            else if "{[".contains(token) { start(token) start("(") }
            else if token == ")" { finish() finish-modifier() }
            else if "}]".contains(token) { finish() finish() finish-modifier() }
            else if token == "|" { finish() start("(") }
            else if "+-×↧↥<≤=@▽,⧻⍳⇌⍏⍖·○".contains(token) {
                start(token)
                finish()
                finish-modifier()
            } else {
                start("_")
                let buffer = ""
                for c length(token) {
                    let c = token.letter(c)
                    if c == "_" {
                        if not(buffer == "") {
                            start(buffer)
                            finish()
                            &buffer = ""
                        }
                    } else {
                        &buffer = buffer.join(c)
                    }
                }
                if not(buffer == "") {
                    start(buffer)
                    finish()
                }
                finish()
                finish-modifier()
            }
        }
    }

    fn finish-modifier {
        if "/\\".contains(ast-ops.at(last(parser-stack))) {
            finish()
        }
    }

    fn start(_ op: String) {
        ast-ops.push(op)
        ast-sizes.push(0)
        parser-stack.push(length(ast-ops))
    }

    fn finish {
        ast-sizes.replace(index: last(parser-stack), with: length(ast-ops) - last(parser-stack) + 1)
        parser-stack.delete(index: length(parser-stack))
    }

    fn si(_ node: Num) -> Num {
        let op = op(node)
        if op == "(" {} # TODO
        else if op == "_" { return 0 }
        else if "+-×↧↥<≤=@▽,".contains(op) { return 2 }
        else if "/\\".contains(op) {
            # TODO
            return 1
        }
        else if "⧻⍳⇌⍏⍖·○".contains(op) { return 1 }
        else if op == "{" {} # TODO
        else if op == "[" {} # TODO
        else {} # Unknown op
    }

    fn so(_ node: Num) -> Num {
        let op = op(node)
        if op == "(" {} # TODO
        else if "_+-×↧↥<≤=@▽,⧻⍳⇌⍏⍖·".contains(op) { return 1 }
        else if "/\\".contains(op) {
            # TODO
            return 1
        }
        else if op == "○" { return 0 }
        else if op == "{" {} # TODO
        else if op == "[" {} # TODO
        else {} # Unknown op
    }

    inline fn op(_ node: Num) -> String {
        ast-ops.at(node)
    }
}
